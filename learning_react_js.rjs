18003474934

8664780032

600+ 240
600 +


https://reactjs.org/
learning react.js

setup https://reactjs.org/docs/try-react.html


                                                /////////////////////////
                                                //  Create React app   //
                                                /////////////////////////


latest js features, nice developer experience optimizes app production

npm install -g create-react-app
create-react-app my-app

cd my-app
npm start

no node modules or promises, just lying around in my computer, refer back here to learn how to use
create-react-app

https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react


    npm init
    npm install --save react react-dom

                            Enabling ES6 and JSX

We recommend using React with Babel to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React.


so install babel with babel-preset-react and babel-preset-env and enable them in your .babelrc configuration, and you’re good to go.


https://babeljs.io/docs/setup/


Choose your tool (try CLI)

https://www.hipstercode.com/tutorial/29/


    react is a javascipt library
    react uses webpaack a module bundler that makes things easier to deal with
    uses jsx (a mix of js and html) and ecmascript2015, (modern version of js)
    however some browsers do not support this, babel is a complier that converts it to raw js

to hard to install so I'll use the big external file instead

















https://reactjs.org/docs/hello-world.html

                            ----------starting with react.js--------

    ReactDOM.render(
      <h1>Hello, world!</h1>,
      document.getElementById('root')
    );

    react programs go in a js file


                                -------Introducing JSX-----------

    const element = <h1>Hello, world!</h1>;
    
is known as jsx

react doesn't need jsx but its helpful when you need to find errors


        --Embedding Expressions in JSX--

to embed js in jsx use curly braces

    { [js] }

also use parentheses around these braces to avoid semicolon insertions


you can use JSX for conditionals functions and so on
You may use quotes to specify string literals as attributes:

    const element = <div tabIndex="0"></div>;

You may also use curly braces to embed a JavaScript expression in an attribute:

    const element = <img src={user.avatarUrl}></img>;

do not use both curly braces and quotes

empty tags

    const element = <img src={user.avatarUrl} />;

jsx tags can have children



            ------------------JSX Prevents Injection Attacks------------

to prevent

    const title = response.potentiallyMaliciousInput;
    // This is safe:
    const element = <h1>{title}</h1>;

By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application.



                --------------JSX Represents Objects-------------

Babel compiles JSX down to React.createElement() calls.

    const element = (
      <h1 className="greeting">
        Hello, world!
      </h1>
    );
    
    ==
    
    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Hello, world!'
    );


the method checks for bugs


                    -----------------Rendering Elements------------------

elements are the smallest building blocks of reacts

we call this a “root” DOM node because everything inside it will be managed by React DOM.

        <div id="root"></div>

Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you can have several isolated "root" DOM

To render a React element into a root DOM node, pass both to ReactDOM.render():

    const element = <h1>Hello, world</h1>;
    ReactDOM.render(element, document.getElementById('root'));


reactDOM elements are immutable the only way to change it is to create a new element and pass it to reactDOM to repalce

however, react knows what to replace and does not tear down the whole element




                ----------------------Components and Props---------------------


Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.

like functions, accpet input [props] and output react elements describing the visual objects



                --------------------Functional and Class Components----------------

simplest way to write a js component is to make a function

can also use an ES6 class

    class Welcome extends React.Component {
      render() {
        return <h1>Hello, {this.props.name}</h1>;
      }
    }


                ------------------Rendering a Component ------------------------

When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.

always use capital letters for components

    
    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }
    
    const element = <Welcome name="Sara" />;
    ReactDOM.render(
      element,
      document.getElementById('root')
    );



                ----------------Composing Components-----------------------

can make a component that is connected to other componets, so when have choices of creating a compoment or a component object

    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }
    
    function App() {
      return (
        <div>
          <Welcome name="Sara" />
          <Welcome name="Cahal" />
          <Welcome name="Edite" />
        </div>
      );
    }
    
    welcome compoent in app component
    ReactDOM.render(
      <App />,
      document.getElementById('root')
    );



            -----------------------Extracting Components-----------------

you can split components into smaller ones

        function Comment(props) {
          return (
            <div className="Comment">
              <div className="UserInfo">
                <img className="Avatar"
                  src={props.author.avatarUrl}
                  alt={props.author.name}
                />
                <div className="UserInfo-name">
                  {props.author.name}
                </div>
              </div>
              <div className="Comment-text">
                {props.text}
              </div>
              <div className="Comment-date">
                {formatDate(props.date)}
              </div>
            </div>
          );
        }

First, we will extract Avatar:

    function Avatar(props) {
      return (
        <img className="Avatar"
          src={props.user.avatarUrl}
          alt={props.user.name}
        />
    
      );
    }

We recommend naming props from the component’s own point of view rather than the context in which it is being used.

then extract UserInfo

        function UserInfo(props) {
          return (
            <div className="UserInfo">
              <Avatar user={props.user} />
              <div className="UserInfo-name">
                {props.user.name}
              </div>
            </div>
          );
        }

final work

    function Comment(props) {
      return (
        <div className="Comment">
          <UserInfo user={props.author} />
          <div className="Comment-text">
            {props.text}
          </div>
          <div className="Comment-date">
            {formatDate(props.date)}
          </div>
        </div>
      );
    }


                -------------------------Props are Read-Only-------------------------

    a component must never change its props

                ----------------------State and Lifecycle--------------------------

we wil l make a clock component that can set up its own timer and update itself every second.

We can start by encapsulating how the clock looks:

then add a state to the clock component


                    -----------------Converting a Function to a Class---------------

to convert a component to a class

        Create an ES6 class, with the same name, that extends React.Component.
        
        Add a single empty method to it called render().
        
        Move the body of the function into the render() method.
        
        Replace props with this.props in the render() body.
        
        Delete the remaining empty function declaration.


    ----------------------adding local state to a class-------------------


    Replace this.props.date with this.state.date in the render() method:
    Add a class constructor that assigns the initial this.state:
    Note how we pass props to the base constructor:

from

        function Clock(props) {
          return (
            <div>
              <h1>Hello, world!</h1>
              <h2>It is {props.date.toLocaleTimeString()}.</h2>
            </div>
          );
        }
        
        function tick() {
          ReactDOM.render(
            <Clock date={new Date()} />,
            document.getElementById('root')
          );
        }
        
        setInterval(tick, 1000);







to
        class Clock extends React.Component {
          constructor(props) {
            super(props);
            this.state = {date: new Date()};
          }
        
          render() {
            return (
              <div>
                <h1>Hello, world!</h1>
                <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
              </div>
            );
          }
        }
        
        ReactDOM.render(
          <Clock />,
          document.getElementById('root')
        );

            -------------------Adding Lifecycle Methods to a Class------------------

in applications with many components we want to free up space when the DOM  is destroyed

MOUNTING -when we render a component to the DOM.

UNMOUNTING - when we want to clear the timer

lifecycle hooks= methods to take care of this

      componentDidMount() {
        this.timerID = setInterval(
          () => this.tick(),
          1000
        );
      }

    //good to setup timers here

    //While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.
    
    //If you don’t use something in render(), it shouldn’t be in the state.
    
    
when we remove the item we use this

      componentWillUnmount() {
        clearInterval(this.timerID);
      }
        
componentDidMount() and componentWillUnmount() react know about these, and makes these calls to hooks so you dont have to figure out when a component is rendered in the DOM or not

final code ---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);







---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=


            -----------------Using State Correctly-------------------

to re-render a component

        this.setState({comment: 'Hello'});

to calculate the next state use a prevState, becuase everything is updated in async

        this.setState((prevState, props) => ({
          counter: prevState.counter + props.increment
        }));


When you call setState(), React merges the object you provide into the current state.

      constructor(props) {
        super(props);
        this.state = {
          posts: [],
          comments: []
        };
      }

to update, everything is affected on at at time

      componentDidMount() {
        fetchPosts().then(response => {
          this.setState({
            posts: response.posts
          });
        });
    
        fetchComments().then(response => {
          this.setState({
            comments: response.comments
          });
        });
      }



            ------------------The Data Flows Down-----------------------

a state is local, or encapsulated because its only for the component that owns or sets it
a component can choose to pass its state down as props to its children

    <h2>It is {this.state.date.toLocaleTimeString()}.</h2>

basically its saying a state can be used by its children, but the child doesn't know about it so you have to implement something




