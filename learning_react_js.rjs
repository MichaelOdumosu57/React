18003474934

8664780032

600+ 240
600 +


https://reactjs.org/
learning react.js

setup https://reactjs.org/docs/try-react.html


                                                /////////////////////////
                                                //  Create React app   //
                                                /////////////////////////


latest js features, nice developer experience optimizes app production

npm install -g create-react-app
create-react-app my-app

cd my-app
npm start

no node modules or promises, just lying around in my computer, refer back here to learn how to use
create-react-app

https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react


    npm init
    npm install --save react react-dom

                            Enabling ES6 and JSX

We recommend using React with Babel to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React.


so install babel with babel-preset-react and babel-preset-env and enable them in your .babelrc configuration, and you’re good to go.


https://babeljs.io/docs/setup/


Choose your tool (try CLI)

https://www.hipstercode.com/tutorial/29/


    react is a javascipt library
    react uses webpaack a module bundler that makes things easier to deal with
    uses jsx (a mix of js and html) and ecmascript2015, (modern version of js)
    however some browsers do not support this, babel is a complier that converts it to raw js

to hard to install so I'll use the big external file instead

















https://reactjs.org/docs/hello-world.html

                            ----------starting with react.js--------

    ReactDOM.render(
      <h1>Hello, world!</h1>,
      document.getElementById('root')
    );

    react programs go in a js file


                                -------Introducing JSX-----------

    const element = <h1>Hello, world!</h1>;

is known as jsx

react doesn't need jsx but its helpful when you need to find errors


        --Embedding Expressions in JSX--

to embed js in jsx use curly braces

    { [js] }

also use parentheses around these braces to avoid semicolon insertions


you can use JSX for conditionals functions and so on
You may use quotes to specify string literals as attributes:

    const element = <div tabIndex="0"></div>;

You may also use curly braces to embed a JavaScript expression in an attribute:

    const element = <img src={user.avatarUrl}></img>;

do not use both curly braces and quotes

empty tags

    const element = <img src={user.avatarUrl} />;

jsx tags can have children



            ------------------JSX Prevents Injection Attacks------------

to prevent

    const title = response.potentiallyMaliciousInput;
    // This is safe:
    const element = <h1>{title}</h1>;

By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application.



                --------------JSX Represents Objects-------------

Babel compiles JSX down to React.createElement() calls.

    const element = (
      <h1 className="greeting">
        Hello, world!
      </h1>
    );

    ==

    const element = React.createElement(
      'h1',
      {className: 'greeting'},
      'Hello, world!'
    );


the method checks for bugs


                    -----------------Rendering Elements------------------

elements are the smallest building blocks of reacts

we call this a “root” DOM node because everything inside it will be managed by React DOM.

        <div id="root"></div>

Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you can have several isolated "root" DOM

To render a React element into a root DOM node, pass both to ReactDOM.render():

    const element = <h1>Hello, world</h1>;
    ReactDOM.render(element, document.getElementById('root'));


reactDOM elements are immutable the only way to change it is to create a new element and pass it to reactDOM to repalce

however, react knows what to replace and does not tear down the whole element




                ----------------------Components and Props---------------------


Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.

like functions, accpet input [props] and output react elements describing the visual objects



                --------------------Functional and Class Components----------------

simplest way to write a js component is to make a function

can also use an ES6 class

    class Welcome extends React.Component {
      render() {
        return <h1>Hello, {this.props.name}</h1>;
      }
    }


                ------------------Rendering a Component ------------------------

When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.

always use capital letters for components


    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }

    const element = <Welcome name="Sara" />;
    ReactDOM.render(
      element,
      document.getElementById('root')
    );



                ----------------Composing Components-----------------------

can make a component that is connected to other componets, so when have choices of creating a compoment or a component object

    function Welcome(props) {
      return <h1>Hello, {props.name}</h1>;
    }

    function App() {
      return (
        <div>
          <Welcome name="Sara" />
          <Welcome name="Cahal" />
          <Welcome name="Edite" />
        </div>
      );
    }

    welcome compoent in app component
    ReactDOM.render(
      <App />,
      document.getElementById('root')
    );



            -----------------------Extracting Components-----------------

you can split components into smaller ones

        function Comment(props) {
          return (
            <div className="Comment">
              <div className="UserInfo">
                <img className="Avatar"
                  src={props.author.avatarUrl}
                  alt={props.author.name}
                />
                <div className="UserInfo-name">
                  {props.author.name}
                </div>
              </div>
              <div className="Comment-text">
                {props.text}
              </div>
              <div className="Comment-date">
                {formatDate(props.date)}
              </div>
            </div>
          );
        }

First, we will extract Avatar:

    function Avatar(props) {
      return (
        <img className="Avatar"
          src={props.user.avatarUrl}
          alt={props.user.name}
        />

      );
    }

We recommend naming props from the component’s own point of view rather than the context in which it is being used.

then extract UserInfo

        function UserInfo(props) {
          return (
            <div className="UserInfo">
              <Avatar user={props.user} />
              <div className="UserInfo-name">
                {props.user.name}
              </div>
            </div>
          );
        }

final work

    function Comment(props) {
      return (
        <div className="Comment">
          <UserInfo user={props.author} />
          <div className="Comment-text">
            {props.text}
          </div>
          <div className="Comment-date">
            {formatDate(props.date)}
          </div>
        </div>
      );
    }


                -------------------------Props are Read-Only-------------------------

    a component must never change its props

                ----------------------State and Lifecycle--------------------------

we wil l make a clock component that can set up its own timer and update itself every second.

We can start by encapsulating how the clock looks:

then add a state to the clock component


                    -----------------Converting a Function to a Class---------------

to convert a component to a class

        Create an ES6 class, with the same name, that extends React.Component.

        Add a single empty method to it called render().

        Move the body of the function into the render() method.

        Replace props with this.props in the render() body.

        Delete the remaining empty function declaration.


    ----------------------adding local state to a class-------------------


    Replace this.props.date with this.state.date in the render() method:
    Add a class constructor that assigns the initial this.state:
    Note how we pass props to the base constructor:

from

        function Clock(props) {
          return (
            <div>
              <h1>Hello, world!</h1>
              <h2>It is {props.date.toLocaleTimeString()}.</h2>
            </div>
          );
        }

        function tick() {
          ReactDOM.render(
            <Clock date={new Date()} />,
            document.getElementById('root')
          );
        }

        setInterval(tick, 1000);







to
        class Clock extends React.Component {
          constructor(props) {
            super(props);
            this.state = {date: new Date()};
          }

          render() {
            return (
              <div>
                <h1>Hello, world!</h1>
                <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
              </div>
            );
          }
        }

        ReactDOM.render(
          <Clock />,
          document.getElementById('root')
        );

            -------------------Adding Lifecycle Methods to a Class------------------

in applications with many components we want to free up space when the DOM  is destroyed

MOUNTING -when we render a component to the DOM.

UNMOUNTING - when we want to clear the timer

lifecycle hooks= methods to take care of this

      componentDidMount() {
        this.timerID = setInterval(
          () => this.tick(),
          1000
        );
      }

    //good to setup timers here

    //While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.

    //If you don’t use something in render(), it shouldn’t be in the state.


when we remove the item we use this

      componentWillUnmount() {
        clearInterval(this.timerID);
      }

componentDidMount() and componentWillUnmount() react know about these, and makes these calls to hooks so you dont have to figure out when a component is rendered in the DOM or not

final code ---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=

class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () => this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      <div>
        <h1>Hello, world!</h1>
        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);







---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=---=-=-=-=-=--=--=


            -----------------Using State Correctly-------------------

to re-render a component

        this.setState({comment: 'Hello'});

to calculate the next state use a prevState, becuase everything is updated in async

        this.setState((prevState, props) => ({
          counter: prevState.counter + props.increment
        }));


When you call setState(), React merges the object you provide into the current state.

      constructor(props) {
        super(props);
        this.state = {
          posts: [],
          comments: []
        };
      }

to update, everything is affected on at at time

      componentDidMount() {
        fetchPosts().then(response => {
          this.setState({
            posts: response.posts
          });
        });

        fetchComments().then(response => {
          this.setState({
            comments: response.comments
          });
        });
      }



            ------------------The Data Flows Down-----------------------

a state is local, or encapsulated because its only for the component that owns or sets it
a component can choose to pass its state down as props to its children

    <h2>It is {this.state.date.toLocaleTimeString()}.</h2>

basically its saying a state can be used by its children, but the child doesn't know about it so you have to implement something


            --------------------Handling Events------------------
to assign a function to an event

    <button onClick={activateLasers}>
      Activate Lasers
    </button>

to cancel a default event

        function ActionLink() {
          function handleClick(e) {
            e.preventDefault();
            console.log('The link was clicked.');
          }
        
          return (
            <a href="#" onClick={handleClick}>
              Click me
            </a>
          );
        }

to toggle, its really a focus on how actions are binded to events


        class Toggle extends React.Component {
          constructor(props) {
            super(props);
            this.state = {isToggleOn: true};
        
            // This binding is necessary to make `this` work in the callback
            this.handleClick = this.handleClick.bind(this);
          }
        
          handleClick() {
            this.setState(prevState => ({
              isToggleOn: !prevState.isToggleOn
            }));
          }
        
          render() {
            return (
              <button onClick={this.handleClick}>
                {this.state.isToggleOn ? 'ON' : 'OFF'}
              </button>
            );
          }
        }
        
        ReactDOM.render(
          <Toggle />,
          document.getElementById('root')
        );


            -------------Passing Arguments to Event Handlers----------------

<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>


its better to use the protoptype bind where you need it



            --------------------Conditional Rendering------------------

same as js if, else


        -----------Element Variables---------

storing elements in variables can help you dynamic enable conditional parts of your website, without changing everything else

you can do this by using stateful component here known as Login Control

        class LoginControl extends React.Component {
          constructor(props) {
            super(props);
            this.handleLoginClick = this.handleLoginClick.bind(this);
            this.handleLogoutClick = this.handleLogoutClick.bind(this);
            this.state = {isLoggedIn: false};
          }
        
          handleLoginClick() {
            this.setState({isLoggedIn: true});
          }
        
          handleLogoutClick() {
            this.setState({isLoggedIn: false});
          }
        
          render() {
            const isLoggedIn = this.state.isLoggedIn;
        
            let button = null;
            if (isLoggedIn) {
              button = <LogoutButton onClick={this.handleLogoutClick} />;
            } else {
              button = <LoginButton onClick={this.handleLoginClick} />;
            }
        
            return (
              <div>
                <Greeting isLoggedIn={isLoggedIn} />
                {button}
              </div>
            );
          }
        }
        
        ReactDOM.render(
          <LoginControl />,
          document.getElementById('root')
        );


    -------------shorten conditionals---------

    -------use if with && operator if you want to conditionally include an element ------

        function Mailbox(props) {
          const unreadMessages = props.unreadMessages;
          return (
        ----------
            <div>
              <h1>Hello!</h1>
              {unreadMessages.length > 0 &&
                <h2>
                  You have {unreadMessages.length} unread messages.
                </h2>
              }
            </div>
        -------------
          );
        }
        
        const messages = ['React', 'Re: React', 'Re:Re: React'];
        ReactDOM.render(
          <Mailbox unreadMessages={messages} />,
          document.getElementById('root')
        );



------------------------Forms---------------------

HTML form elements naturally keep their internal state

if you want this in react, it there for you but you can use controlled compoents
bascially they handle form submission and data about the form

In React, mutable state is typically kept in the state property of components, and only updated with setState()


this updates with each key stroke so you can make sure the user is typing the right thing

+++++++++++++++++++++++++
        class NameForm extends React.Component {
          constructor(props) {
            super(props);
            this.state = {value: ''};
        
            this.handleChange = this.handleChange.bind(this);
            this.handleSubmit = this.handleSubmit.bind(this);
          }
        
          handleChange(event) {
            this.setState({value: event.target.value});
          }
        
          handleSubmit(event) {
            alert('A name was submitted: ' + this.state.value);
            event.preventDefault();
          }
        
          render() {
            return (
              <form onSubmit={this.handleSubmit}>
                <label>
                  Name:
                  <input type="text" value={this.state.value} onChange={this.handleChange} />
                </label>
                <input type="submit" value="Submit" />
              </form>
            );
          }
        }
++++++++++

so if you wanted to enforce all uppercase

        handleChange(event) {
          this.setState({value: event.target.value.toUpperCase()});
        }



    -----------------The textarea Tag-----------------

if you want to put default text in a textarea tag with react

+++++++++++++++==
    class EssayForm extends React.Component {
      constructor(props) {
        super(props);
        this.state = {
          value: 'Please write an essay about your favorite DOM element.'
        };
    
        this.handleChange = this.handleChange.bind(this);
        this.handleSubmit = this.handleSubmit.bind(this);
      }
    
      handleChange(event) {
        this.setState({value: event.target.value});
      }
    
      handleSubmit(event) {
        alert('An essay was submitted: ' + this.state.value);
        event.preventDefault();
      }
    
      render() {
        return (
          <form onSubmit={this.handleSubmit}>
            <label>
              Essay:
              <textarea value={this.state.value} onChange={this.handleChange} />
            </label>
            <input type="submit" value="Submit" />
          </form>
        );
      }
}
----------------------------


react dropdowns

+++++++++++++++++++++++++
class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {value: 'coconut'};

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({value: event.target.value});
  }

  handleSubmit(event) {
    alert('Your favorite flavor is: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Pick your favorite La Croix flavor:
          <select value={this.state.value} onChange={this.handleChange}>
            <option value="grapefruit">Grapefruit</option>
            <option value="lime">Lime</option>
            <option value="coconut">Coconut</option>
            <option value="mango">Mango</option>
          </select>
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
+++++++++++++++++++=

if you want to select multiple options do this

    <select multiple={true} value={['B', 'C']}>


if you are handling multiple inputs at a time

----------------------
        class Reservation extends React.Component {
          constructor(props) {
            super(props);
            this.state = {
              isGoing: true,
              numberOfGuests: 2
            };
        
            this.handleInputChange = this.handleInputChange.bind(this);
          }
        
          handleInputChange(event) {
            const target = event.target;
            const value = target.type === 'checkbox' ? target.checked : target.value;
            const name = target.name;
        
            this.setState({
              [name]: value
            });
          }
        
          render() {
            return (
              <form>
                <label>
                  Is going:
                  <input
                    name="isGoing"
                    type="checkbox"
                    checked={this.state.isGoing}
                    onChange={this.handleInputChange} />
                </label>
                <br />
                <label>
                  Number of guests:
                  <input
                    name="numberOfGuests"
                    type="number"
                    value={this.state.numberOfGuests}
                    onChange={this.handleInputChange} />
                </label>
              </form>
            );
          }
        }
=======================================

used ES6 computed property name to get the job done

    this.setState({
      [name]: value
    });


--------control input value ------

if you to control the time to wait before a user inputs you can do

        ReactDOM.render(<input value="hi" />, mountNode);
        
        setTimeout(function() {
          ReactDOM.render(<input value={null} />, mountNode);
        }, 1000);

        --------------------Lifting State Up----------------------------

when you want several components to reflect the same changing data here is what you do



+++++++++++++++++++++++++++++++++++++++++++++++
        function BoilingVerdict(props) {
          if (props.celsius >= 100) {
            return <p>The water would boil.</p>;
          }
          return <p>The water would not boil.</p>;
        }

        class Calculator extends React.Component {
          constructor(props) {
            super(props);
            this.handleChange = this.handleChange.bind(this);
            this.state = {temperature: ''};
          }
        
          handleChange(e) {
            this.setState({temperature: e.target.value});
          }
        
          render() {
            const temperature = this.state.temperature;
            return (
              <fieldset>
                <legend>Enter temperature in Celsius:</legend>
                <input
                  value={temperature}
                  onChange={this.handleChange} />
        
                <BoilingVerdict
                  celsius={parseFloat(temperature)} />
        
              </fieldset>
            );
          }
        }

+++++++++++++++++++++++++++++++++++++++++++++


to add a second input

[[[[[[[[[[[[[[[[[[[[[
        const scaleNames = {
          c: 'Celsius',
          f: 'Fahrenheit'
        };
        
        class TemperatureInput extends React.Component {
          constructor(props) {
            super(props);
            this.handleChange = this.handleChange.bind(this);
            this.state = {temperature: ''};
          }
        
          handleChange(e) {
            this.setState({temperature: e.target.value});
          }
        
          render() {
            const temperature = this.state.temperature;
            const scale = this.props.scale;
            return (
              <fieldset>
                <legend>Enter temperature in {scaleNames[scale]}:</legend>
                <input value={temperature}
                       onChange={this.handleChange} />
              </fieldset>
            );
          }
        }


//to render it in the calculator

    class Calculator extends React.Component {
      render() {
        return (
          <div>
            <TemperatureInput scale="c" />
            <TemperatureInput scale="f" />
          </div>
        );
      }
    }
[[[[[[[[[[[[[[[[[[[[[[[[




---------------------Writing Conversion Functions-------------------------

        function toCelsius(fahrenheit) {
          return (fahrenheit - 32) * 5 / 9;
        }
        
        function toFahrenheit(celsius) {
          return (celsius * 9 / 5) + 32;
        }

// conversion checks

        function tryConvert(temperature, convert) {
          const input = parseFloat(temperature);
          if (Number.isNaN(input)) {
            return '';
          }
          const output = convert(input);
          const rounded = Math.round(output * 1000) / 1000;
          return rounded.toString();
        }

            --------------------Lifting State Up----------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
to make sure that any change in one input reflects changes in both

        class Calculator extends React.Component {
          constructor(props) {
            super(props);
            this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
            this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
            this.state = {temperature: '', scale: 'c'};
          }
        
          handleCelsiusChange(temperature) {
            this.setState({scale: 'c', temperature});
          }
        
          handleFahrenheitChange(temperature) {
            this.setState({scale: 'f', temperature});
          }
        
          render() {
            const scale = this.state.scale;
            const temperature = this.state.temperature;
            const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
            const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;
        
            return (
              <div>
                <TemperatureInput
                  scale="c"
                  temperature={celsius}
                  onTemperatureChange={this.handleCelsiusChange} />
        
                <TemperatureInput
                  scale="f"
                  temperature={fahrenheit}
                  onTemperatureChange={this.handleFahrenheitChange} />
        
                <BoilingVerdict
                  celsius={parseFloat(celsius)} />
        
              </div>
            );
          }
        }

        class TemperatureInput extends React.Component {
          constructor(props) {
            super(props);
            this.handleChange = this.handleChange.bind(this);
          }
        
          handleChange(e) {
            this.props.onTemperatureChange(e.target.value);
          }
        
          render() {
            const temperature = this.props.temperature;
            const scale = this.props.scale;
            return (
              <fieldset>
                <legend>Enter temperature in {scaleNames[scale]}:</legend>
                <input value={temperature}
                       onChange={this.handleChange} />
              </fieldset>
            );
          }
        }


function BoilingVerdict(props) {
  if (props.celsius >= 100) {
    return <p>The water would boil.</p>;
  }
  return <p>The water would not boil.</p>;
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



--------------------------Composition vs Inheritance----------------------------

        ------------------Containment---------------

components  do not know about chirldren, use the props.children to pass those elements directly to the parent


        function FancyBorder(props) {
          return (
            <div className={'FancyBorder FancyBorder-' + props.color}>
              {props.children}
            </div>
          );
        }


//allows other components to pass arbitrary children to them

        function WelcomeDialog() {
          return (
            <FancyBorder color="blue">
            -------------------------------------------------
              <h1 className="Dialog-title">
                Welcome
              </h1>
              <p className="Dialog-message">
                Thank you for visiting our spacecraft!
              </p>
            --------------------------------------------------------
            </FancyBorder>
          );
        }

if you have different type of info to be passed as different children, you don't need to call them children then

        function SplitPane(props) {
          return (
            <div className="SplitPane">
            ------------------------------------------
              <div className="SplitPane-left">
                {props.left}
              </div>
              <div className="SplitPane-right">
                {props.right}
              </div>
            ------------------------------------------
            </div>
          );
        }
        
        function App() {
          return (
            <SplitPane
            ------------------------------------------
              left={
                <Contacts />
              }
              right={
                <Chat />
            ------------------------------------------
              } />
          );
        }


        -----------Specialization-----------

Sometimes we have special components. what they do is fill in the data left default by their more general counterparts

        function Dialog(props) {
          return (
            <FancyBorder color="blue">
            ------------------------------------------
              <h1 className="Dialog-title">
                {props.title}
              </h1>
              <p className="Dialog-message">
                {props.message}
              </p>
            ------------------------------------------
            </FancyBorder>
          );
        }
        
        function WelcomeDialog() {
          return (
            <Dialog
            ------------------------------------------
              title="Welcome"
              message="Thank you for visiting our spacecraft!" />
            ------------------------------------------
          );
        }

works the same for component classes

------------------------------------------------

        function Dialog(props) {
          return (
            <FancyBorder color="blue">
              <h1 className="Dialog-title">
                {props.title}
              </h1>
              <p className="Dialog-message">
                {props.message}
              </p>
              {props.children}
            </FancyBorder>
          );
        }
        
        class SignUpDialog extends React.Component {
          constructor(props) {
            super(props);
            this.handleChange = this.handleChange.bind(this);
            this.handleSignUp = this.handleSignUp.bind(this);
            this.state = {login: ''};
          }
        
          render() {
            return (
              <Dialog title="Mars Exploration Program"
                      message="How should we refer to you?">
                <input value={this.state.login}
                       onChange={this.handleChange} />
        
                <button onClick={this.handleSignUp}>
                  Sign Me Up!
                </button>
              </Dialog>
            );
          }
        
          handleChange(e) {
            this.setState({login: e.target.value});
          }
        
          handleSignUp() {
            alert(`Welcome aboard, ${this.state.login}!`);
          }
        }

------------------------------------------------


        -----So What About Inheritance?-So What About Inheritance?-------

If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.


        ------------Thinking in React---- Thinking in React-------------

    ------- searchable product data table using React.--------

 1. ----------Break The UI Into A Component Hierarchy--------

a component should always be doing one thing
if your model was built good, the json data will fit nicely

You’ll see here that we have five components in our simple app. We’ve italicized the data each component represents.

FilterableProductTable (orange): contains the entirety of the example
SearchBar (blue): receives all user input
ProductTable (green): displays and filters the data collection based on user input
ProductCategoryRow (turquoise): displays a heading for each category
ProductRow (red): displays a row for each product

then make a hierchy
FilterableProductTable
    SearchBar
    ProductTable
        ProductCategoryRow
        ProductRow




                -------build a stantic version in react-----------
